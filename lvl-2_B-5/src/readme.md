

-------------Interview Questions--------------------------------------------





1. Differences Between Interfaces and Types in TypeScript
----------------------------------------------------------------
Interfaces are extendable and used mainly for object shapes. Types are more flexible, supporting unions, primitives, and intersections. Interfaces support merging; types don’t. Both help structure data in TypeScript





2. Use of the keyof Keyword in TypeScript
-----------------------------------------------------
The keyof keyword returns a union of an object’s keys. It’s used for type-safe property access, ensuring that only existing keys can be referenced, reducing runtime errors and improving code safety.






3. Difference Between any, unknown, and never Types
-------------------------------------------------------
any disables type checks. unknown is safer—requires checks before use. never means a value that never occurs, like functions that throw errors. Use them wisely for safe and predictable code.




4. Use of Enums in TypeScript
--------------------------------------------------------------------
Enums define named constants. They improve code clarity and reduce errors. TypeScript supports numeric and string enums, commonly used for roles, states, or categories like weekdays or user types.






5. What is Type Inference in TypeScript?
---------------------------------------------------------
Type inference automatically determines a variable’s type based on its value. This reduces the need for manual annotations, improves code readability, and still gives strong type safety during development.









6. How Does TypeScript Improve Code Quality and Maintainability?
------------------------------------------------------------------------------
TypeScript catches errors early with static typing. It makes code easier to read, refactor, and maintain. It also supports better tooling, autocomplete, and documentation, leading to fewer bugs and cleaner projects.



7. Union and Intersection Types in TypeScript
--------------------------------------------------------------------------------
Union types allow a variable to hold multiple types. Intersection types combine multiple types into one. Together, they offer flexibility and precision when modeling complex or varying data structures in applications.



                     


        This fundamentals asignment project i will use built in keywords are:
        ------------------------------------------------------------------
1. type alis 
2. Interface 
3. Generics '
4. Types-intersection
5. typeof keys 
6. enum 
7. rest opearator
8. distructuring
9. types Gurds
10. asynchronus 
11. enum
12. tarnary
13. Assertion
14. colluse nullis
15. Array
16. object


OOP concepts are:
-------------------

1. class
2. constructor
3. this keyword
4. privite
5. Getter
6. Setter
7. Method
8. super class
9. sub class 
10. extends 
11. new keyword


Using Terminal
------------------
Default Terminal: tsc --watch





                            My own Typescript blogs content
                            --------------------------------

 My TypeScript Learning Journey: From Basics to Confidence
When I first started learning TypeScript, it felt like a strict version of JavaScript. But as I progressed, I began to appreciate its power. TypeScript isn't just a language; it's a layer of safety and clarity over JavaScript. It allows us to define what kind of data we're working with, detect errors early, and write code that's easier to maintain. In this blog, I’ll share how learning about objects, arrays, union types, destructuring, strings, the spread operator, and generics helped me level up as a web developer.

Objects were the first concept that made me realize the true benefit of TypeScript. In JavaScript, we can create any kind of object, but in TypeScript, we define exactly what properties the object should have and what type of data each property must hold. This clarity helps reduce bugs, especially in large projects. Knowing that an object must include a name as a string or an age as a number means I don’t have to guess or worry about incorrect data.

Next came arrays. TypeScript allows me to be specific about what kind of data an array can hold. Whether it's an array of numbers, strings, or custom objects, TypeScript helps ensure consistency. I no longer fear pushing the wrong data type into an array because TypeScript warns me immediately if I make a mistake. This simple concept has saved me hours of debugging time.

Then I explored union types. Sometimes, a value needs to be either one type or another — for example, a field that accepts either a string or a number. Union types gave me the flexibility I needed, but with the same level of control. Instead of letting anything go, TypeScript let me clearly state, “this can be A or B, but not something else.” This is incredibly helpful when working with APIs or user inputs that aren’t always consistent.

Destructuring was already familiar to me from JavaScript, but in TypeScript, it became more powerful. I learned how to extract values from arrays or objects while still keeping type safety intact. This made my functions cleaner and more readable, and I no longer worried about accessing undefined values by mistake.

Working with strings in TypeScript also became more reliable. In JavaScript, I could mistakenly call a string method on a non-string value and only realize it at runtime. But TypeScript catches those errors at compile time. If I try to call a string method on something that isn’t a string, it tells me right away. This gave me a strong sense of security while writing string-based logic.

The spread operator was another powerful feature I was already using in JavaScript, but now I could use it confidently with TypeScript. Whether copying arrays or combining objects, TypeScript ensured that the result respected the defined types. This made it easier to update data immutably without losing control over structure or types.

Lastly, I learned about generics, which at first seemed scary but turned out to be one of the most powerful tools in TypeScript. Generics allowed me to create reusable functions and components that could work with any type while still keeping type safety. Instead of rewriting the same logic for numbers, strings, or custom objects, I could write one generic version that adapted based on the type I passed in. It made my code more scalable, reusable, and elegant.

Overall, my journey with TypeScript has been incredibly rewarding. It taught me not just how to write safer code, but how to think more clearly as a developer. Each concept — from basic types to advanced generics — added a layer of understanding that I now rely on every day. TypeScript is no longer just a tool for me; it's a mindset — one that values clarity, predictability, and long-term success in software development.






                          --My submiited Github Public Repo--
                          ------------------------------------


                          Github Repo Link:
                          


                     


